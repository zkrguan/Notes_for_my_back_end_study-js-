/*
Sequelizee is used Object relational mapping.
    This maps our JS objects to table and rows within our database and 
    Automatically exectue relevant SQL commands on the database whenver data using our models is updated. 
    THis saves us the trouble of manually writing complex SQL statements whenver we wish to update the back end 
    database to reflect changes made by the user. 
    We can simply update our data and let seuuelize do the rest!
*/
const { result, forIn } = require('lodash');
const { stringify } = require('querystring');
const Sequelize = require('sequelize');

// set up sequelize to point to our postgres database
/* 5 eles of the connection to the database
databaseName
usernName
host
host 
port
On heroku almost everything is generated by itself. 
*/ 
var sequelize = new Sequelize('', '', '', {
  host: '',
  dialect: 'postgres',
  port: 5432,
  dialectOptions: {
      ssl: { rejectUnauthorized: false }
  },
  query: { raw: true }
});


// First of all, just like SQL we need to define the Model(table)//

// Define a "Name" model

var Person = sequelize.define('Person', {
    fName: Sequelize.STRING,  // first Name
    lName: Sequelize.STRING, // Last Name
    hobby: Sequelize.STRING,
});


// C => create. 
// Just like how I create objects in the previous examples//
// syntax modelName.create({Filling your attributes in the creating object way})
// Create and the another CRUD will return a promise back as well (Handling a promise should be ENGRAVED in the brain right?)//
// If not Homelander should lase it into your brain right?//
// sequelize.sync().then(function(){
//     Person.create({
//         fName: "Guan",
//         lName: "Zhaokai",
//         hobby: "Watching the Boys"
//     }).then((result)=>{
//         console.log(result.fName, result.lName,`the lame hobby is ${result.hobby}.`);
//     }).catch((err)=>{
//         console.log(`The error is ${err}`);
//     })

//     Person.create({
//         fName: "Antony",
//         lName: "Starr",
//         hobby: "Drinking milk"
//     }).then((result)=>{
//         console.log(result.fName, result.lName,`the lame hobby is ${result.hobby}.`);
//     }).catch((err)=>{
//         console.log(`The error is ${err}`);
//     })

//     Person.create({
//         fName: "Billy",
//         // Intentionally left a mistake, let's fix it latter in the U part//
//         fName: "Butcher",
//         hobby: "Injecting V24"
//     }).then((result)=>{
//         console.log(result.fName, result.lName,`the lame hobby is ${result.hobby}.`);
//     }).catch((err)=>{
//         console.log(`The error is ${err}`);
//     })
// })

// // R=> Read 
// // Remember the SELECT statement from SQL?//
// sequelize.sync().then(()=>{
//     // select fName from People //
//     Person.findAll({
//         attributes:['fName']
//     }).then((result)=>{
//         result.forEach(element => { console.log(element.fName)});
//     }).catch((err)=>{
//         console.log(err);
//     });

//     //Don't you feel this is just like we are writting SQL statements in the JSON format LOL//
//     Person.findAll({
//         attributes:['hobby'],
//         where:{
//             id:2
//         }
//     }).then((data)=>{
//         data.forEach(x=>console.log(x.hobby));
//     }).catch((err)=>{
//         console.log(err);
//     });
// });


//U=> update

// sequelize.sync().then(()=>{
//     Person.update({
//         fName:"Billy",
//         lName:"Butcher"
//         // Be extra careful with the },{  part, most annoying syntax so far//
//     },{
//         where:{ID: 3}
//     }).then((result)=>{console.log(`Updated Records ${result.id}`)});

//     Person.findAll({

//     }).then((data)=>{
//         data.forEach(element=>console.log(element));
//     });

// });

//D delete
//Using modelName.destory({ })

sequelize.sync().then(()=>{
   Person.destroy({
     where:{id:3}
   })
   .then(()=>{Person.findAll({
    }).then((data)=>{
    data.forEach(element=>console.log(element));
    
  });})    

})
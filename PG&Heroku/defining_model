/*
Sequelizee is used Object relational mapping.
    This maps our JS objects to table and rows within our database and 
    Automatically exectue relevant SQL commands on the database whenver data using our models is updated. 
    THis saves us the trouble of manually writing complex SQL statements whenver we wish to update the back end 
    database to reflect changes made by the user. 
    We can simply update our data and let seuuelize do the rest!
*/
const Sequelize = require('sequelize');

// set up sequelize to point to our postgres database
/* 5 eles of the connection to the database
databaseName
usernName
host
host 
port
On heroku almost everything is generated by itself. 
*/ 
var sequelize = new Sequelize('d5s5vmooglpg55', 'mnxbtdhwjqfirw', '22f7cc9ce00f8c456af68fedb0e9ad3b4c10836aaaf6835b41f8b4d07971f2f1', {
    host: 'ec2-34-233-115-14.compute-1.amazonaws.com',
    dialect: 'postgres',
    port: 5432,
    dialectOptions: {
        ssl: { rejectUnauthorized: false }
    },
    query: { raw: true }
});



/*
    Set up all of our models is the key before we actually implment the code to work with data
    Each model technically corresponds to a table within our database, 
    what we are really doing is defining table. 
    Each column of a table within our databases stores a specific type of data. 
    (recall from the database course?)
    literally like 
        CREATE TABLE TABLE_NAME(
    COLUMN1 DATATYPE(LENGTH) COLUMN_CONSTRIAT,
    COLUMN2 DATATYPE(LENGTH) COLUMN_CONSTRIAT,
    TABLE_CONSTRAINTS
    );
    Isn't the sequelize module sick? 
    Remember how much work we need to make while we are implementing an app to access our sql database by using C++?
    
    Some common datatypes:
        Sequelize.STRING - A variable length string. Default length 255
        Sequelize.TEXT - An unlimited length text column.
        Sequelize.INTEGER - A 32 bit integer.
        Sequelize.FLOAT - Floating point number (4-byte precision).
        Sequelize.DOUBLE - Floating point number (8-byte precision)
        Sequelize.DATE - A datetime column
        Sequelize.TIME - A time column
        Sequelize.BOOLEAN - A boolean column
*/

// Simple Example for creating a Data Model
// var SampleEntry = sequelize.define('SampleEntry', {
//     title: Sequelize.STRING,  // entry title
//     author: Sequelize.STRING, // author of the entry
//     entry: Sequelize.TEXT, // main text for the entry
//     views: Sequelize.INTEGER, // number of views
//     postDate: Sequelize.DATE // Date the entry was posted
// });





/*
// Some stuff school does not teach!//
// We could also have some data validation before the data actually store into the DB//
// 1. Validations are not constraints, they are on the sequelize level.
// 2. If the validation fails, no sql query will be sent to the DB (safety++)

    constraints are defined on the SQL level
    If a constraint fails, an error will be thrown by the DB, and the sequelize will forward this error to JS.
    (SQL query was sent to the DB, and an error was thown)

    refers to https://sequelize.org/docs/v6/core-concepts/validations-and-constraints/ for more implement syntaxs.
    This is very important especially to those who wants to work at the back end.
*/



/*
    Recall from the DB course?
    The tables could have relationships between them. (the Diagram we draw before with the crow foot notation)
    The FKs and associations?
    Same as models in the sequelize.
    You can define the relation in the following code.
*/

// Define our "User" and "Task" models
var User = sequelize.define('User', {
    fullName: Sequelize.STRING, // the user's full name (ie: "Jason Bourne")
    title: Sequelize.STRING // the user's title within the project (ie, developer)
});

var Task = sequelize.define('Task', {
    title: Sequelize.STRING, // title of the task
    description: Sequelize.TEXT // main text for the task
});


// this is associating the two table
// Just like those crow foots we made
/*NOTE: other relationships can be defined using the following functions:

    belongsTo()
    hasOne()
    belongsToMany()
*/
User.hasMany(Task)

// // Associate Tasks with user & automatically create a foreign key
// // relationship on "Task" via an automatically generated "UserId" field
sequelize.sync().then(function () {
    
    // Create user "Jason Bourne"
    User.create({
        fullName: "Jason Bourne",
        title: "developer"
    }).then(function (user) {

        console.log("user created");
        
            // Create "Task 1" for the new user
        Task.create({
            title: "Task 1",
            description: "coding",
            UserId: user.id // set the correct Userid foreign key
        }).then(function(){ console.log("Task 1 created")})
          .catch((err)=>{console.log(err)});

        // Create "Task 2" for the new user
        Task.create({
            title: "Task 2",
            description: "breaking necks",
            UserId: user.id // set the correct Userid foreign key
        }).then(function(){ console.log("Task 2 created")});
    });

});


// The results from the PGadmin
// 1	"Task 1"	"coding"	"2022-07-10 21:44:04.616+00"	"2022-07-10 21:44:04.616+00"	1
// 2	"Task 2"	"breaking necks"	"2022-07-10 21:44:04.616+00"	"2022-07-10 21:44:04.616+00"	1


/* Altough the syntax is not that easy to remember, 
    Compare to writting this api in C++, this is like nothing.
    Efficient and powerful
    But less funs from designs.
*/




/*
Sequelizee is used Object relational mapping.
    This maps our JS objects to table and rows within our database and 
    Automatically exectue relevant SQL commands on the database whenver data using our models is updated. 
    THis saves us the trouble of manually writing complex SQL statements whenver we wish to update the back end 
    database to reflect changes made by the user. 
    We can simply update our data and let seuuelize do the rest!
*/
const Sequelize = require('sequelize');

// set up sequelize to point to our postgres database
/* 5 eles of the connection to the database
databaseName
usernName
host
host 
port
On heroku almost everything is generated by itself. 
*/ 
var sequelize = new Sequelize('d5s5vmooglpg55', 'mnxbtdhwjqfirw', '22f7cc9ce00f8c456af68fedb0e9ad3b4c10836aaaf6835b41f8b4d07971f2f1', {
    host: 'ec2-34-233-115-14.compute-1.amazonaws.com',
    dialect: 'postgres',
    port: 5432,
    dialectOptions: {
        ssl: { rejectUnauthorized: false }
    },
    query: { raw: true }
});


// This is an example from the top of the code//
var Project = sequelize.define('Project',{
    title: Sequelize.STRING,
    description: Sequelize.TEXT
})


// Synch the DB with our models and auto add the table if the table is not there//
sequelize.sync().then(function () {
    // create a new "Project" and add it to the database
    Project.create({
        title: 'Project1',
        description: 'First Project'
    }).then(function (project) {
        // you can now access the newly created Project via the variable project
        console.log("success!")
    }).catch(function (error) {
        console.log("something went wrong!");
    });
});


// Define a "Project" model using the user-definedID//
// Also disable the createdAt and updatedAt//

var Project = sequelize.define('Project', {
    project_id: {
        type: Sequelize.INTEGER,
        primaryKey: true, // use "project_id" as a primary key
        autoIncrement: true // automatically increment the value
    },
    title: Sequelize.STRING,
    description: Sequelize.TEXT
},{
    createdAt: false, // disable createdAt
    updatedAt: false // disable updatedAt
});

// Sum from line 31 - 51 //
/*
After exectuing those
Go to the PG admin 
Database=> myDatabaseName => Schemas => Public=> table => project => right click project=> view/edit data

Line 31 we did not define the ID, createAt, updatedAt
Where are these from?
    Those columns are from the sequelize module. (The one we imported from the topline)
    Whenever we define a new model, we automatically get the ID,createdAt, updatedAt.
    This is handy 
        because the we DID NOT CREATE PK for this table.( recall how Important PK is from Database Class)
        Also, the createdAt and updatedAt are both widely used. 

Although it is useful, you do have the choice to disable the features and use your own PK.

    Comment out the line 31 - 50 
    Cut and paste the 56-68 before the sequalize.sync()


sequlize.sync() 
    First of all, this needs to be completed before we can do anything.
        Why?
        Ensures that all of our models are represented in the database as tables.
        If we have defined a model in our code that does not correspond to a table in the database. 
        Sequelize.sync() will auto create a table. 
    .sync() operation does not need for every operation. 
        Only when the server starts to ensure that models are correctly represented as tables within the database. 
    After .sync successfully ran, we can start working with the data. 
    
    .then() and .catch don't they look familar? Why we used it here?
        Both sync() and create() return a promise
    
    Now the structure is quite clear right?
        If sync() resolves sucessfully,
            We then use Project.create() method and pass it some data ( in the object format)
            If the result from create is a success, we then print out the message "sucess"
            If not, then we print out the error from the call back inside the catch
*/


